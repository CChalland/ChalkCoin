{"ast":null,"code":"import NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport Adapters from \"next-auth/adapters\";\nimport prisma from \"../../../contexts/prisma\";\nimport { compareSync } from \"bcrypt\";\nlet userAccount = null;\n\nconst authHandler = (req, res) => NextAuth(req, res, options);\n\nexport default authHandler;\nconst options = {\n  providers: [Providers.Credentials({\n    id: \"credentials\",\n    name: \"Login\",\n\n    async authorize(credentials) {\n      const user = await prisma.user.findFirst({\n        where: {\n          email: credentials.email\n        }\n      });\n      const passwordTrue = await compareSync(credentials.password, user.password);\n\n      if (user && passwordTrue) {\n        userAccount = user;\n        return user;\n      } else {\n        return null;\n      }\n    }\n\n  }), Providers.Email({\n    server: {\n      host: process.env.SMTP_HOST,\n      port: Number(process.env.SMTP_PORT),\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASSWORD\n      }\n    },\n    from: process.env.SMTP_FROM\n  }), Providers.GitHub({\n    clientId: process.env.GITHUB_ID,\n    clientSecret: process.env.GITHUB_SECRET\n  })],\n  session: {\n    // Use JSON Web Tokens for session instead of database sessions.\n    // This option can be used with or without a database for users/accounts.\n    // Note: `jwt` is automatically set to `true` if no database is specified.\n    jwt: true,\n    // Seconds - How long until an idle session expires and is no longer valid.\n    maxAge: 30 * 24 * 60 * 60,\n    // 30 days\n    // Seconds - Throttle how frequently to write to database to extend a session.\n    // Use it to limit write operations. Set to 0 to always update the database.\n    // Note: This option is ignored if using JSON Web Tokens\n    updateAge: 24 * 60 * 60 // 24 hours\n\n  },\n  callbacks: {\n    async jwt(token, user, account, profile, isNewUser) {\n      console.log(\"jwt token\", token);\n      console.log(\"jwt user\", user);\n      console.log(\"jwt account\", account);\n      console.log(\"jwt profile\", profile);\n      console.log(\"jwt isNewUser\", isNewUser); // Persist the OAuth access_token to the token right after signin\n\n      if (account) {\n        token.accessToken = account.access_token;\n      }\n\n      if (user) {\n        token.user = user; // token.username = user.username;\n        // token.email = user.email;\n        // token.password = user.password;\n        // token.name = user.name;\n        // token.picture = user.image;\n        // token.paypal = user.paypal\n      }\n\n      return token;\n    },\n\n    async session(session, token, user) {\n      console.log(\"session session\", session);\n      console.log(\"session user\", user);\n      console.log(\"session token\", token); // Send properties to the client, like an access_token from a provider.\n\n      session.accessToken = token.accessToken;\n      session.user = token.user; // delete token.password;\n      // session.user = token;\n\n      return session;\n    }\n\n  },\n  pages: {\n    signIn: \"/LoginRegister\",\n    verifyRequest: \"/VerifyRequest\",\n    newUser: \"/NewUser\"\n  },\n  // @ts-ignore\n  adapter: Adapters.Prisma.Adapter({\n    prisma\n  }),\n  secret: process.env.SECRET\n}; // import NextAuth from \"next-auth\";\n// import Providers from \"next-auth/providers\";\n// import CredentialsProvider from \"next-auth/providers/credentials\";\n// import Adapters from \"next-auth/adapters\";\n// import prisma from \"../../../contexts/prisma\";\n// import { compareSync } from \"bcrypt\";\n// let userAccount = null;\n// const authHandler = (req, res) => NextAuth(req, res, options);\n// export default authHandler;\n// const options = {\n// \tproviders: [\n// \t\tCredentialsProvider({\n// \t\t\t// The name to display on the sign in form (e.g. 'Sign in with...')\n// \t\t\tname: \"Credentials\",\n// \t\t\t// The credentials is used to generate a suitable form on the sign in page.\n// \t\t\t// You can specify whatever fields you are expecting to be submitted.\n// \t\t\t// e.g. domain, username, password, 2FA token, etc.\n// \t\t\t// credentials: {\n// \t\t\t// \tusername: { label: \"Username\", type: \"text\", placeholder: \"jsmith\" },\n// \t\t\t// \tpassword: {  label: \"Password\", type: \"password\" }\n// \t\t\t// },\n// \t\t\tasync authorize(credentials) {\n// \t\t\t\tconsole.log(credentials);\n// \t\t\t\tconst user = await prisma.user.findFirst({\n// \t\t\t\t\twhere: {\n// \t\t\t\t\t\temail: credentials.loginEmail,\n// \t\t\t\t\t},\n// \t\t\t\t});\n// \t\t\t\tconsole.log(\"the user\", user);\n// \t\t\t\tpasswordTrue = await compareSync(credentials.loginPassword, user.password);\n// \t\t\t\tconsole.log(\"password True\", passwordTrue);\n// \t\t\t\tif (user !== null) {\n// \t\t\t\t\tuserAccount = user;\n// \t\t\t\t\treturn user;\n// \t\t\t\t} else {\n// \t\t\t\t\treturn null;\n// \t\t\t\t}\n// \t\t\t},\n// \t\t}),\n// \t\t// Providers.Credentials({\n// \t\t// \tid: \"credentials\",\n// \t\t// \tname: \"Login\",\n// \t\t// \tasync authorize(credentials) {\n// \t\t// \t\tconsole.log(credentials);\n// \t\t// \t\tconst user = await prisma.user.findFirst({\n// \t\t// \t\t\twhere: {\n// \t\t// \t\t\t\temail: credentials.loginEmail,\n// \t\t// \t\t\t},\n// \t\t// \t\t});\n// \t\t// \t\tconsole.log(\"the user\", user);\n// \t\t// \t\tpasswordTrue = await compareSync(credentials.loginPassword, user.password);\n// \t\t// \t\tconsole.log(\"password True\", passwordTrue);\n// \t\t// \t\tif (user !== null) {\n// \t\t// \t\t\tuserAccount = user;\n// \t\t// \t\t\treturn user;\n// \t\t// \t\t} else {\n// \t\t// \t\t\treturn null;\n// \t\t// \t\t}\n// \t\t// \t},\n// \t\t// }),\n// \t\tProviders.Email({\n// \t\t\tserver: {\n// \t\t\t\thost: process.env.SMTP_HOST,\n// \t\t\t\tport: Number(process.env.SMTP_PORT),\n// \t\t\t\tauth: {\n// \t\t\t\t\tuser: process.env.SMTP_USER,\n// \t\t\t\t\tpass: process.env.SMTP_PASSWORD,\n// \t\t\t\t},\n// \t\t\t},\n// \t\t\tfrom: process.env.SMTP_FROM,\n// \t\t}),\n// \t\tProviders.GitHub({\n// \t\t\tclientId: process.env.GITHUB_ID,\n// \t\t\tclientSecret: process.env.GITHUB_SECRET,\n// \t\t}),\n// \t],\n// \tsession: {\n// \t\t// Use JSON Web Tokens for session instead of database sessions.\n// \t\t// This option can be used with or without a database for users/accounts.\n// \t\t// Note: `jwt` is automatically set to `true` if no database is specified.\n// \t\tjwt: true,\n// \t\t// Seconds - How long until an idle session expires and is no longer valid.\n// \t\tmaxAge: 30 * 24 * 60 * 60, // 30 days\n// \t\t// Seconds - Throttle how frequently to write to database to extend a session.\n// \t\t// Use it to limit write operations. Set to 0 to always update the database.\n// \t\t// Note: This option is ignored if using JSON Web Tokens\n// \t\tupdateAge: 24 * 60 * 60, // 24 hours\n// \t},\n// \tcallbacks: {\n// \t\tasync jwt(token, user, account, profile, isNewUser) {\n// \t\t\tconsole.log(\"jwt token\", token);\n// \t\t\tconsole.log(\"jwt user\", user);\n// \t\t\tconsole.log(\"jwt account\", account);\n// \t\t\tconsole.log(\"jwt profile\", profile);\n// \t\t\tconsole.log(\"jwt isNewUser\", isNewUser);\n// \t\t\tif (user) {\n// \t\t\t\tdelete user.password;\n// \t\t\t\ttoken.user = user;\n// \t\t\t\t// token.accessToken = user.token;\n// \t\t\t}\n// \t\t\treturn token;\n// \t\t},\n// \t\tasync session(session, user, token) {\n// \t\t\tconsole.log(\"session session\", session);\n// \t\t\tconsole.log(\"session user\", user);\n// \t\t\tconsole.log(\"session token\", token);\n// \t\t\tdelete user.password;\n// \t\t\tsession.user = user;\n// \t\t\treturn await session;\n// \t\t},\n// \t},\n// \tpages: {\n// \t\tsignIn: \"/LoginRegister\",\n// \t\tverifyRequest: \"/VerifyRequest\",\n// \t\tnewUser: \"/NewUser\",\n// \t},\n// \t// @ts-ignore\n// \tadapter: Adapters.Prisma.Adapter({\n// \t\tprisma,\n// \t}),\n// \tsecret: process.env.SECRET,\n// };","map":{"version":3,"sources":["/Users/colechalland/Projects/CryptoCurrency/BEToken/pages/api/auth/[...nextauth].js"],"names":["NextAuth","Providers","Adapters","prisma","compareSync","userAccount","authHandler","req","res","options","providers","Credentials","id","name","authorize","credentials","user","findFirst","where","email","passwordTrue","password","Email","server","host","process","env","SMTP_HOST","port","Number","SMTP_PORT","auth","SMTP_USER","pass","SMTP_PASSWORD","from","SMTP_FROM","GitHub","clientId","GITHUB_ID","clientSecret","GITHUB_SECRET","session","jwt","maxAge","updateAge","callbacks","token","account","profile","isNewUser","console","log","accessToken","access_token","pages","signIn","verifyRequest","newUser","adapter","Prisma","Adapter","secret","SECRET"],"mappings":"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A5B;AACAX,MAAAA,OAAO,CAAC1B,IAAR,GAAe+B,KAAK,CAAC/B,IAArB,CAPmC,CASnC;AACA;;AAEA,aAAO0B,OAAP;AACA;;AApCS,GAlDI;AAwFfa,EAAAA,KAAK,EAAE;AACNC,IAAAA,MAAM,EAAE,gBADF;AAENC,IAAAA,aAAa,EAAE,gBAFT;AAGNC,IAAAA,OAAO,EAAE;AAHH,GAxFQ;AA6Ff;AACAC,EAAAA,OAAO,EAAEzD,QAAQ,CAAC0D,MAAT,CAAgBC,OAAhB,CAAwB;AAChC1D,IAAAA;AADgC,GAAxB,CA9FM;AAkGf2D,EAAAA,MAAM,EAAErC,OAAO,CAACC,GAAR,CAAYqC;AAlGL,CAAhB,C,CAqGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sourcesContent":["import NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport Adapters from \"next-auth/adapters\";\nimport prisma from \"../../../contexts/prisma\";\nimport { compareSync } from \"bcrypt\";\nlet userAccount = null;\nconst authHandler = (req, res) => NextAuth(req, res, options);\nexport default authHandler;\n\nconst options = {\n\tproviders: [\n\t\tProviders.Credentials({\n\t\t\tid: \"credentials\",\n\t\t\tname: \"Login\",\n\t\t\tasync authorize(credentials) {\n\t\t\t\tconst user = await prisma.user.findFirst({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\temail: credentials.email,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tconst passwordTrue = await compareSync(credentials.password, user.password);\n\t\t\t\tif (user && passwordTrue) {\n\t\t\t\t\tuserAccount = user;\n\t\t\t\t\treturn user;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\t\tProviders.Email({\n\t\t\tserver: {\n\t\t\t\thost: process.env.SMTP_HOST,\n\t\t\t\tport: Number(process.env.SMTP_PORT),\n\t\t\t\tauth: {\n\t\t\t\t\tuser: process.env.SMTP_USER,\n\t\t\t\t\tpass: process.env.SMTP_PASSWORD,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfrom: process.env.SMTP_FROM,\n\t\t}),\n\t\tProviders.GitHub({\n\t\t\tclientId: process.env.GITHUB_ID,\n\t\t\tclientSecret: process.env.GITHUB_SECRET,\n\t\t}),\n\t],\n\tsession: {\n\t\t// Use JSON Web Tokens for session instead of database sessions.\n\t\t// This option can be used with or without a database for users/accounts.\n\t\t// Note: `jwt` is automatically set to `true` if no database is specified.\n\t\tjwt: true,\n\n\t\t// Seconds - How long until an idle session expires and is no longer valid.\n\t\tmaxAge: 30 * 24 * 60 * 60, // 30 days\n\n\t\t// Seconds - Throttle how frequently to write to database to extend a session.\n\t\t// Use it to limit write operations. Set to 0 to always update the database.\n\t\t// Note: This option is ignored if using JSON Web Tokens\n\t\tupdateAge: 24 * 60 * 60, // 24 hours\n\t},\n\tcallbacks: {\n\t\tasync jwt(token, user, account, profile, isNewUser) {\n\t\t\tconsole.log(\"jwt token\", token);\n\t\t\tconsole.log(\"jwt user\", user);\n\t\t\tconsole.log(\"jwt account\", account);\n\t\t\tconsole.log(\"jwt profile\", profile);\n\t\t\tconsole.log(\"jwt isNewUser\", isNewUser);\n\n\t\t\t// Persist the OAuth access_token to the token right after signin\n\t\t\tif (account) {\n\t\t\t\ttoken.accessToken = account.access_token;\n\t\t\t}\n\t\t\tif (user) {\n\t\t\t\ttoken.user = user;\n\t\t\t\t// token.username = user.username;\n\t\t\t\t// token.email = user.email;\n\t\t\t\t// token.password = user.password;\n\t\t\t\t// token.name = user.name;\n\t\t\t\t// token.picture = user.image;\n\t\t\t\t// token.paypal = user.paypal\n\t\t\t}\n\t\t\treturn token;\n\t\t},\n\t\tasync session(session, token, user) {\n\t\t\tconsole.log(\"session session\", session);\n\t\t\tconsole.log(\"session user\", user);\n\t\t\tconsole.log(\"session token\", token);\n\n\t\t\t// Send properties to the client, like an access_token from a provider.\n\t\t\tsession.accessToken = token.accessToken;\n\t\t\tsession.user = token.user;\n\n\t\t\t// delete token.password;\n\t\t\t// session.user = token;\n\n\t\t\treturn session;\n\t\t},\n\t},\n\tpages: {\n\t\tsignIn: \"/LoginRegister\",\n\t\tverifyRequest: \"/VerifyRequest\",\n\t\tnewUser: \"/NewUser\",\n\t},\n\t// @ts-ignore\n\tadapter: Adapters.Prisma.Adapter({\n\t\tprisma,\n\t}),\n\n\tsecret: process.env.SECRET,\n};\n\n// import NextAuth from \"next-auth\";\n// import Providers from \"next-auth/providers\";\n// import CredentialsProvider from \"next-auth/providers/credentials\";\n// import Adapters from \"next-auth/adapters\";\n// import prisma from \"../../../contexts/prisma\";\n// import { compareSync } from \"bcrypt\";\n// let userAccount = null;\n\n// const authHandler = (req, res) => NextAuth(req, res, options);\n// export default authHandler;\n\n// const options = {\n// \tproviders: [\n// \t\tCredentialsProvider({\n// \t\t\t// The name to display on the sign in form (e.g. 'Sign in with...')\n// \t\t\tname: \"Credentials\",\n// \t\t\t// The credentials is used to generate a suitable form on the sign in page.\n// \t\t\t// You can specify whatever fields you are expecting to be submitted.\n// \t\t\t// e.g. domain, username, password, 2FA token, etc.\n// \t\t\t// credentials: {\n// \t\t\t// \tusername: { label: \"Username\", type: \"text\", placeholder: \"jsmith\" },\n// \t\t\t// \tpassword: {  label: \"Password\", type: \"password\" }\n// \t\t\t// },\n// \t\t\tasync authorize(credentials) {\n// \t\t\t\tconsole.log(credentials);\n// \t\t\t\tconst user = await prisma.user.findFirst({\n// \t\t\t\t\twhere: {\n// \t\t\t\t\t\temail: credentials.loginEmail,\n// \t\t\t\t\t},\n// \t\t\t\t});\n// \t\t\t\tconsole.log(\"the user\", user);\n// \t\t\t\tpasswordTrue = await compareSync(credentials.loginPassword, user.password);\n// \t\t\t\tconsole.log(\"password True\", passwordTrue);\n// \t\t\t\tif (user !== null) {\n// \t\t\t\t\tuserAccount = user;\n// \t\t\t\t\treturn user;\n// \t\t\t\t} else {\n// \t\t\t\t\treturn null;\n// \t\t\t\t}\n// \t\t\t},\n// \t\t}),\n\n// \t\t// Providers.Credentials({\n// \t\t// \tid: \"credentials\",\n// \t\t// \tname: \"Login\",\n// \t\t// \tasync authorize(credentials) {\n// \t\t// \t\tconsole.log(credentials);\n// \t\t// \t\tconst user = await prisma.user.findFirst({\n// \t\t// \t\t\twhere: {\n// \t\t// \t\t\t\temail: credentials.loginEmail,\n// \t\t// \t\t\t},\n// \t\t// \t\t});\n// \t\t// \t\tconsole.log(\"the user\", user);\n// \t\t// \t\tpasswordTrue = await compareSync(credentials.loginPassword, user.password);\n// \t\t// \t\tconsole.log(\"password True\", passwordTrue);\n// \t\t// \t\tif (user !== null) {\n// \t\t// \t\t\tuserAccount = user;\n// \t\t// \t\t\treturn user;\n// \t\t// \t\t} else {\n// \t\t// \t\t\treturn null;\n// \t\t// \t\t}\n// \t\t// \t},\n// \t\t// }),\n// \t\tProviders.Email({\n// \t\t\tserver: {\n// \t\t\t\thost: process.env.SMTP_HOST,\n// \t\t\t\tport: Number(process.env.SMTP_PORT),\n// \t\t\t\tauth: {\n// \t\t\t\t\tuser: process.env.SMTP_USER,\n// \t\t\t\t\tpass: process.env.SMTP_PASSWORD,\n// \t\t\t\t},\n// \t\t\t},\n// \t\t\tfrom: process.env.SMTP_FROM,\n// \t\t}),\n// \t\tProviders.GitHub({\n// \t\t\tclientId: process.env.GITHUB_ID,\n// \t\t\tclientSecret: process.env.GITHUB_SECRET,\n// \t\t}),\n// \t],\n// \tsession: {\n// \t\t// Use JSON Web Tokens for session instead of database sessions.\n// \t\t// This option can be used with or without a database for users/accounts.\n// \t\t// Note: `jwt` is automatically set to `true` if no database is specified.\n// \t\tjwt: true,\n\n// \t\t// Seconds - How long until an idle session expires and is no longer valid.\n// \t\tmaxAge: 30 * 24 * 60 * 60, // 30 days\n\n// \t\t// Seconds - Throttle how frequently to write to database to extend a session.\n// \t\t// Use it to limit write operations. Set to 0 to always update the database.\n// \t\t// Note: This option is ignored if using JSON Web Tokens\n// \t\tupdateAge: 24 * 60 * 60, // 24 hours\n// \t},\n// \tcallbacks: {\n// \t\tasync jwt(token, user, account, profile, isNewUser) {\n// \t\t\tconsole.log(\"jwt token\", token);\n// \t\t\tconsole.log(\"jwt user\", user);\n// \t\t\tconsole.log(\"jwt account\", account);\n// \t\t\tconsole.log(\"jwt profile\", profile);\n// \t\t\tconsole.log(\"jwt isNewUser\", isNewUser);\n// \t\t\tif (user) {\n// \t\t\t\tdelete user.password;\n// \t\t\t\ttoken.user = user;\n// \t\t\t\t// token.accessToken = user.token;\n// \t\t\t}\n// \t\t\treturn token;\n// \t\t},\n// \t\tasync session(session, user, token) {\n// \t\t\tconsole.log(\"session session\", session);\n// \t\t\tconsole.log(\"session user\", user);\n// \t\t\tconsole.log(\"session token\", token);\n// \t\t\tdelete user.password;\n// \t\t\tsession.user = user;\n\n// \t\t\treturn await session;\n// \t\t},\n// \t},\n// \tpages: {\n// \t\tsignIn: \"/LoginRegister\",\n// \t\tverifyRequest: \"/VerifyRequest\",\n// \t\tnewUser: \"/NewUser\",\n// \t},\n// \t// @ts-ignore\n// \tadapter: Adapters.Prisma.Adapter({\n// \t\tprisma,\n// \t}),\n\n// \tsecret: process.env.SECRET,\n// };\n"]},"metadata":{},"sourceType":"module"}