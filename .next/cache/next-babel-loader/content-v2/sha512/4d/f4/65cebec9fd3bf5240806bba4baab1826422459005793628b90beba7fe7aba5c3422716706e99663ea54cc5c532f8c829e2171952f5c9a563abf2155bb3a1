{"ast":null,"code":"import prisma from \"../../contexts/prisma\";\nimport { getSession } from \"next-auth/client\";\nexport default (async (req, res) => {\n  const session = await getSession({\n    req\n  });\n\n  if (req.method === \"GET\") {\n    let bets = await prisma.bet.findMany({\n      where: {\n        accepted: false\n      }\n    }).map(async bet => {\n      bet.details = JSON.parse(bet.details);\n      return bet;\n    });\n    const betData = await Promise.all(bets);\n    console.log(betData);\n    return res.json({\n      message: \"testing\"\n    }); // return res.status(405).json({ message: \"Method not allowed\" });\n  } else if (req.method === \"POST\") {\n    const bet = req.body;\n\n    if (session) {\n      try {\n        let betData = {\n          amount: parseFloat(bet.amount),\n          details: JSON.stringify(bet.details),\n          currency: bet.currency,\n          requester: {\n            connect: {\n              id: session.user.id\n            }\n          }\n        };\n        if (bet.recipientId) betData.recipient = {\n          connect: {\n            id: bet.recipientId\n          }\n        }; // const createdBet = await prisma.bet.create({\n        // \tdata: betData,\n        // });\n        // return res.json(createdBet);\n\n        return res.json(betData);\n      } catch (e) {\n        console.log(e);\n\n        if (e.code === \"P2002\") {\n          return res.json({\n            error: `There's already an account with that ${e.meta.target[0]}`\n          });\n        } // throw e;\n\n      }\n    }\n  }\n});","map":{"version":3,"sources":["/Users/colechalland/Projects/CryptoCurrency/BEToken/pages/api/bets.js"],"names":["prisma","getSession","req","res","session","method","bets","bet","findMany","where","accepted","map","details","JSON","parse","betData","Promise","all","console","log","json","message","body","amount","parseFloat","stringify","currency","requester","connect","id","user","recipientId","recipient","e","code","error","meta","target"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,uBAAnB;AACA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAClC,QAAMC,OAAO,GAAG,MAAMH,UAAU,CAAC;AAAEC,IAAAA;AAAF,GAAD,CAAhC;;AAEA,MAAIA,GAAG,CAACG,MAAJ,KAAe,KAAnB,EAA0B;AACzB,QAAIC,IAAI,GAAG,MAAMN,MAAM,CAACO,GAAP,CACfC,QADe,CACN;AACTC,MAAAA,KAAK,EAAE;AACNC,QAAAA,QAAQ,EAAE;AADJ;AADE,KADM,EAMfC,GANe,CAMX,MAAOJ,GAAP,IAAe;AACnBA,MAAAA,GAAG,CAACK,OAAJ,GAAcC,IAAI,CAACC,KAAL,CAAWP,GAAG,CAACK,OAAf,CAAd;AACA,aAAOL,GAAP;AACA,KATe,CAAjB;AAUA,UAAMQ,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYX,IAAZ,CAAtB;AACAY,IAAAA,OAAO,CAACC,GAAR,CAAYJ,OAAZ;AAEA,WAAOZ,GAAG,CAACiB,IAAJ,CAAS;AAAEC,MAAAA,OAAO,EAAE;AAAX,KAAT,CAAP,CAdyB,CAezB;AACA,GAhBD,MAgBO,IAAInB,GAAG,CAACG,MAAJ,KAAe,MAAnB,EAA2B;AACjC,UAAME,GAAG,GAAGL,GAAG,CAACoB,IAAhB;;AACA,QAAIlB,OAAJ,EAAa;AACZ,UAAI;AACH,YAAIW,OAAO,GAAG;AACbQ,UAAAA,MAAM,EAAEC,UAAU,CAACjB,GAAG,CAACgB,MAAL,CADL;AAEbX,UAAAA,OAAO,EAAEC,IAAI,CAACY,SAAL,CAAelB,GAAG,CAACK,OAAnB,CAFI;AAGbc,UAAAA,QAAQ,EAAEnB,GAAG,CAACmB,QAHD;AAIbC,UAAAA,SAAS,EAAE;AACVC,YAAAA,OAAO,EAAE;AACRC,cAAAA,EAAE,EAAEzB,OAAO,CAAC0B,IAAR,CAAaD;AADT;AADC;AAJE,SAAd;AAUA,YAAItB,GAAG,CAACwB,WAAR,EAAqBhB,OAAO,CAACiB,SAAR,GAAoB;AAAEJ,UAAAA,OAAO,EAAE;AAAEC,YAAAA,EAAE,EAAEtB,GAAG,CAACwB;AAAV;AAAX,SAApB,CAXlB,CAYH;AACA;AACA;AACA;;AACA,eAAO5B,GAAG,CAACiB,IAAJ,CAASL,OAAT,CAAP;AACA,OAjBD,CAiBE,OAAOkB,CAAP,EAAU;AACXf,QAAAA,OAAO,CAACC,GAAR,CAAYc,CAAZ;;AACA,YAAIA,CAAC,CAACC,IAAF,KAAW,OAAf,EAAwB;AACvB,iBAAO/B,GAAG,CAACiB,IAAJ,CAAS;AAAEe,YAAAA,KAAK,EAAG,wCAAuCF,CAAC,CAACG,IAAF,CAAOC,MAAP,CAAc,CAAd,CAAiB;AAAlE,WAAT,CAAP;AACA,SAJU,CAKX;;AACA;AACD;AACD;AACD,CAhDD","sourcesContent":["import prisma from \"../../contexts/prisma\";\nimport { getSession } from \"next-auth/client\";\n\nexport default async (req, res) => {\n\tconst session = await getSession({ req });\n\n\tif (req.method === \"GET\") {\n\t\tlet bets = await prisma.bet\n\t\t\t.findMany({\n\t\t\t\twhere: {\n\t\t\t\t\taccepted: false,\n\t\t\t\t},\n\t\t\t})\n\t\t\t.map(async (bet) => {\n\t\t\t\tbet.details = JSON.parse(bet.details);\n\t\t\t\treturn bet;\n\t\t\t});\n\t\tconst betData = await Promise.all(bets);\n\t\tconsole.log(betData);\n\n\t\treturn res.json({ message: \"testing\" });\n\t\t// return res.status(405).json({ message: \"Method not allowed\" });\n\t} else if (req.method === \"POST\") {\n\t\tconst bet = req.body;\n\t\tif (session) {\n\t\t\ttry {\n\t\t\t\tlet betData = {\n\t\t\t\t\tamount: parseFloat(bet.amount),\n\t\t\t\t\tdetails: JSON.stringify(bet.details),\n\t\t\t\t\tcurrency: bet.currency,\n\t\t\t\t\trequester: {\n\t\t\t\t\t\tconnect: {\n\t\t\t\t\t\t\tid: session.user.id,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tif (bet.recipientId) betData.recipient = { connect: { id: bet.recipientId } };\n\t\t\t\t// const createdBet = await prisma.bet.create({\n\t\t\t\t// \tdata: betData,\n\t\t\t\t// });\n\t\t\t\t// return res.json(createdBet);\n\t\t\t\treturn res.json(betData);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\tif (e.code === \"P2002\") {\n\t\t\t\t\treturn res.json({ error: `There's already an account with that ${e.meta.target[0]}` });\n\t\t\t\t}\n\t\t\t\t// throw e;\n\t\t\t}\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}