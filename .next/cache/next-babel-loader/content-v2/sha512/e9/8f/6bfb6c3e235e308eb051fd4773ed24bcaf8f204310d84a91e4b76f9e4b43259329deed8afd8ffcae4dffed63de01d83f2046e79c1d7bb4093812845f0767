{"ast":null,"code":"import prisma from \"../../contexts/prisma\";\nimport { getSession } from \"next-auth/client\";\nimport { hashSync } from \"bcrypt\";\nexport default (async (req, res) => {\n  const session = await getSession({\n    req\n  });\n\n  if (req.method === \"GET\") {\n    if (session) {\n      if (req.query.type === \"layout\") {\n        const user = await prisma.user.findUnique({\n          where: {\n            id: session.user.id\n          },\n          select: {\n            id: true,\n            username: true,\n            email: true,\n            name: true,\n            image: true,\n            balance: true,\n            walletAddress: true,\n            accepter: true,\n            recipient: true,\n            requester: true\n          }\n        });\n        return res.json({\n          id: user.id,\n          username: user.username,\n          email: user.email,\n          name: user.name,\n          image: user.image,\n          balance: user.balance,\n          walletAddress: user.walletAddress,\n          openBets: [...user.recipient, ...user.requester].filter(bet => !bet.accepted && !bet.completed),\n          acceptedBets: [...user.accepter, ...user.recipient, ...user.requester].filter(bet => bet.accepted && !bet.completed),\n          completedBets: [...user.accepter, ...user.recipient, ...user.requester].filter(bet => bet.accepted && bet.completed)\n        });\n      } else {\n        return res.json(await prisma.user.findUnique({\n          where: {\n            id: session.user.id\n          },\n          include: {\n            requester: true,\n            accepter: true,\n            recipient: true\n          }\n        }));\n      }\n    } else {\n      return res.json({\n        error: true,\n        message: \"Not logged in.\"\n      });\n    }\n  } else if (req.method === \"POST\") {\n    const user = req.body;\n    delete user.balance;\n    if (user.password) user.password = hashSync(user.password, 10);\n\n    try {\n      const updatedUser = await prisma.user.update({\n        where: {\n          id: session.user.id\n        },\n        data: user\n      });\n      delete updatedUser.password;\n      return res.json(updatedUser);\n    } catch (e) {\n      console.log(e.meta.target);\n\n      if (e.code === \"P2002\") {\n        return res.json({\n          error: `There's already an account with that ${e.meta.target[0]}`\n        });\n      } // throw e;\n\n    }\n  }\n});","map":{"version":3,"sources":["/Users/colechalland/Projects/ChalkCoin/pages/api/currentUser.js"],"names":["prisma","getSession","hashSync","req","res","session","method","query","type","user","findUnique","where","id","select","username","email","name","image","balance","walletAddress","accepter","recipient","requester","json","openBets","filter","bet","accepted","completed","acceptedBets","completedBets","include","error","message","body","password","updatedUser","update","data","e","console","log","meta","target","code"],"mappings":"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","sourcesContent":["import prisma from \"../../contexts/prisma\";\nimport { getSession } from \"next-auth/client\";\nimport { hashSync } from \"bcrypt\";\n\nexport default async (req, res) => {\n\tconst session = await getSession({ req });\n\n\tif (req.method === \"GET\") {\n\t\tif (session) {\n\t\t\tif (req.query.type === \"layout\") {\n\t\t\t\tconst user = await prisma.user.findUnique({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\tid: session.user.id,\n\t\t\t\t\t},\n\t\t\t\t\tselect: {\n\t\t\t\t\t\tid: true,\n\t\t\t\t\t\tusername: true,\n\t\t\t\t\t\temail: true,\n\t\t\t\t\t\tname: true,\n\t\t\t\t\t\timage: true,\n\t\t\t\t\t\tbalance: true,\n\t\t\t\t\t\twalletAddress: true,\n\t\t\t\t\t\taccepter: true,\n\t\t\t\t\t\trecipient: true,\n\t\t\t\t\t\trequester: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\treturn res.json({\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tusername: user.username,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\timage: user.image,\n\t\t\t\t\tbalance: user.balance,\n\t\t\t\t\twalletAddress: user.walletAddress,\n\t\t\t\t\topenBets: [...user.recipient, ...user.requester].filter((bet) => !bet.accepted && !bet.completed),\n\t\t\t\t\tacceptedBets: [...user.accepter, ...user.recipient, ...user.requester].filter(\n\t\t\t\t\t\t(bet) => bet.accepted && !bet.completed\n\t\t\t\t\t),\n\t\t\t\t\tcompletedBets: [...user.accepter, ...user.recipient, ...user.requester].filter(\n\t\t\t\t\t\t(bet) => bet.accepted && bet.completed\n\t\t\t\t\t),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn res.json(\n\t\t\t\t\tawait prisma.user.findUnique({\n\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\tid: session.user.id,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinclude: {\n\t\t\t\t\t\t\trequester: true,\n\t\t\t\t\t\t\taccepter: true,\n\t\t\t\t\t\t\trecipient: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\treturn res.json({ error: true, message: \"Not logged in.\" });\n\t\t}\n\t} else if (req.method === \"POST\") {\n\t\tconst user = req.body;\n\t\tdelete user.balance;\n\t\tif (user.password) user.password = hashSync(user.password, 10);\n\n\t\ttry {\n\t\t\tconst updatedUser = await prisma.user.update({\n\t\t\t\twhere: {\n\t\t\t\t\tid: session.user.id,\n\t\t\t\t},\n\t\t\t\tdata: user,\n\t\t\t});\n\t\t\tdelete updatedUser.password;\n\t\t\treturn res.json(updatedUser);\n\t\t} catch (e) {\n\t\t\tconsole.log(e.meta.target);\n\t\t\tif (e.code === \"P2002\") {\n\t\t\t\treturn res.json({ error: `There's already an account with that ${e.meta.target[0]}` });\n\t\t\t}\n\t\t\t// throw e;\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}