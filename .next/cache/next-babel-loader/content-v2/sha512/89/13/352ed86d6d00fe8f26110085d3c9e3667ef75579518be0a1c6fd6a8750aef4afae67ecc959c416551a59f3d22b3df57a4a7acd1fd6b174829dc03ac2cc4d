{"ast":null,"code":"import NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport Adapters from \"next-auth/adapters\";\nimport prisma from \"../../../contexts/prisma\";\n\nconst authHandler = (req, res) => NextAuth(req, res, options);\n\nexport default authHandler;\nconst options = {\n  providers: [Providers.Credentials({\n    id: \"credentials\",\n    name: \"Login\",\n\n    async authorize(credentials) {\n      const user = await prisma.users.findFirst({\n        where: {\n          email: credentials.email,\n          password: credentials.password\n        }\n      });\n\n      if (user !== null) {\n        userAccount = user;\n        return user;\n      } else {\n        return null;\n      }\n    }\n\n  }), Providers.Email({\n    server: {\n      host: process.env.SMTP_HOST,\n      port: Number(process.env.SMTP_PORT),\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASSWORD\n      }\n    },\n    from: process.env.SMTP_FROM\n  }), Providers.GitHub({\n    clientId: process.env.GITHUB_ID,\n    clientSecret: process.env.GITHUB_SECRET\n  })],\n  callbacks: {\n    async jwt(token, user, account, profile, isNewUser) {\n      //  \"user\" parameter is the object received from \"authorize\"\n      //  \"token\" is being send below to \"session\" callback...\n      //  ...so we set \"user\" param of \"token\" to object from \"authorize\"...\n      //  ...and return it...\n      user && (token.user = user);\n      return Promise.resolve(token); // ...here\n    },\n\n    async session(session, user, sessionToken) {\n      //  \"session\" is current session object\n      //  below we set \"user\" param of \"session\" to value received from \"jwt\" callback\n      session.user = user.user;\n      return Promise.resolve(session);\n    } // async jwt(token, user) {\n    // \tif (user) {\n    // \t\tconsole.log(\"jwt user\", user);\n    // \t\tconsole.log(\"jwt token\", token);\n    // \t\ttoken.accessToken = user.data.token;\n    // \t}\n    // \treturn token;\n    // },\n    // async session(session, token) {\n    // \tconsole.log(\"session\", session);\n    // \tconsole.log(\"session token\", token);\n    // \tsession.accessToken = token.accessToken;\n    // \treturn session;\n    // },\n\n\n  },\n  pages: {\n    signIn: \"/LoginRegister\",\n    newUser: \"/NewUser\"\n  },\n  // @ts-ignore\n  adapter: Adapters.Prisma.Adapter({\n    prisma\n  }),\n  secret: process.env.SECRET\n};","map":{"version":3,"sources":["/Users/colechalland/Projects/CryptoCurrency/BEToken/pages/api/auth/[...nextauth].js"],"names":["NextAuth","Providers","Adapters","prisma","authHandler","req","res","options","providers","Credentials","id","name","authorize","credentials","user","users","findFirst","where","email","password","userAccount","Email","server","host","process","env","SMTP_HOST","port","Number","SMTP_PORT","auth","SMTP_USER","pass","SMTP_PASSWORD","from","SMTP_FROM","GitHub","clientId","GITHUB_ID","clientSecret","GITHUB_SECRET","callbacks","jwt","token","account","profile","isNewUser","Promise","resolve","session","sessionToken","pages","signIn","newUser","adapter","Prisma","Adapter","secret","SECRET"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,WAArB;AACA,OAAOC,SAAP,MAAsB,qBAAtB;AACA,OAAOC,QAAP,MAAqB,oBAArB;AACA,OAAOC,MAAP,MAAmB,0BAAnB;;AAEA,MAAMC,WAAW,GAAG,CAACC,GAAD,EAAMC,GAAN,KAAcN,QAAQ,CAACK,GAAD,EAAMC,GAAN,EAAWC,OAAX,CAA1C;;AACA,eAAeH,WAAf;AAEA,MAAMG,OAAO,GAAG;AACfC,EAAAA,SAAS,EAAE,CACVP,SAAS,CAACQ,WAAV,CAAsB;AACrBC,IAAAA,EAAE,EAAE,aADiB;AAErBC,IAAAA,IAAI,EAAE,OAFe;;AAGrB,UAAMC,SAAN,CAAgBC,WAAhB,EAA6B;AAC5B,YAAMC,IAAI,GAAG,MAAMX,MAAM,CAACY,KAAP,CAAaC,SAAb,CAAuB;AACzCC,QAAAA,KAAK,EAAE;AACNC,UAAAA,KAAK,EAAEL,WAAW,CAACK,KADb;AAENC,UAAAA,QAAQ,EAAEN,WAAW,CAACM;AAFhB;AADkC,OAAvB,CAAnB;;AAOA,UAAIL,IAAI,KAAK,IAAb,EAAmB;AAClBM,QAAAA,WAAW,GAAGN,IAAd;AACA,eAAOA,IAAP;AACA,OAHD,MAGO;AACN,eAAO,IAAP;AACA;AACD;;AAjBoB,GAAtB,CADU,EAoBVb,SAAS,CAACoB,KAAV,CAAgB;AACfC,IAAAA,MAAM,EAAE;AACPC,MAAAA,IAAI,EAAEC,OAAO,CAACC,GAAR,CAAYC,SADX;AAEPC,MAAAA,IAAI,EAAEC,MAAM,CAACJ,OAAO,CAACC,GAAR,CAAYI,SAAb,CAFL;AAGPC,MAAAA,IAAI,EAAE;AACLhB,QAAAA,IAAI,EAAEU,OAAO,CAACC,GAAR,CAAYM,SADb;AAELC,QAAAA,IAAI,EAAER,OAAO,CAACC,GAAR,CAAYQ;AAFb;AAHC,KADO;AASfC,IAAAA,IAAI,EAAEV,OAAO,CAACC,GAAR,CAAYU;AATH,GAAhB,CApBU,EA+BVlC,SAAS,CAACmC,MAAV,CAAiB;AAChBC,IAAAA,QAAQ,EAAEb,OAAO,CAACC,GAAR,CAAYa,SADN;AAEhBC,IAAAA,YAAY,EAAEf,OAAO,CAACC,GAAR,CAAYe;AAFV,GAAjB,CA/BU,CADI;AAqCfC,EAAAA,SAAS,EAAE;AACV,UAAMC,GAAN,CAAUC,KAAV,EAAiB7B,IAAjB,EAAuB8B,OAAvB,EAAgCC,OAAhC,EAAyCC,SAAzC,EAAoD;AACnD;AACA;AACA;AACA;AACAhC,MAAAA,IAAI,KAAK6B,KAAK,CAAC7B,IAAN,GAAaA,IAAlB,CAAJ;AACA,aAAOiC,OAAO,CAACC,OAAR,CAAgBL,KAAhB,CAAP,CANmD,CAMpB;AAC/B,KARS;;AASV,UAAMM,OAAN,CAAcA,OAAd,EAAuBnC,IAAvB,EAA6BoC,YAA7B,EAA2C;AAC1C;AACA;AACAD,MAAAA,OAAO,CAACnC,IAAR,GAAeA,IAAI,CAACA,IAApB;AACA,aAAOiC,OAAO,CAACC,OAAR,CAAgBC,OAAhB,CAAP;AACA,KAdS,CAgBV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AA9BU,GArCI;AAqEfE,EAAAA,KAAK,EAAE;AACNC,IAAAA,MAAM,EAAE,gBADF;AAENC,IAAAA,OAAO,EAAE;AAFH,GArEQ;AAyEf;AACAC,EAAAA,OAAO,EAAEpD,QAAQ,CAACqD,MAAT,CAAgBC,OAAhB,CAAwB;AAChCrD,IAAAA;AADgC,GAAxB,CA1EM;AA8EfsD,EAAAA,MAAM,EAAEjC,OAAO,CAACC,GAAR,CAAYiC;AA9EL,CAAhB","sourcesContent":["import NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport Adapters from \"next-auth/adapters\";\nimport prisma from \"../../../contexts/prisma\";\n\nconst authHandler = (req, res) => NextAuth(req, res, options);\nexport default authHandler;\n\nconst options = {\n\tproviders: [\n\t\tProviders.Credentials({\n\t\t\tid: \"credentials\",\n\t\t\tname: \"Login\",\n\t\t\tasync authorize(credentials) {\n\t\t\t\tconst user = await prisma.users.findFirst({\n\t\t\t\t\twhere: {\n\t\t\t\t\t\temail: credentials.email,\n\t\t\t\t\t\tpassword: credentials.password,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tif (user !== null) {\n\t\t\t\t\tuserAccount = user;\n\t\t\t\t\treturn user;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\t\tProviders.Email({\n\t\t\tserver: {\n\t\t\t\thost: process.env.SMTP_HOST,\n\t\t\t\tport: Number(process.env.SMTP_PORT),\n\t\t\t\tauth: {\n\t\t\t\t\tuser: process.env.SMTP_USER,\n\t\t\t\t\tpass: process.env.SMTP_PASSWORD,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfrom: process.env.SMTP_FROM,\n\t\t}),\n\t\tProviders.GitHub({\n\t\t\tclientId: process.env.GITHUB_ID,\n\t\t\tclientSecret: process.env.GITHUB_SECRET,\n\t\t}),\n\t],\n\tcallbacks: {\n\t\tasync jwt(token, user, account, profile, isNewUser) {\n\t\t\t//  \"user\" parameter is the object received from \"authorize\"\n\t\t\t//  \"token\" is being send below to \"session\" callback...\n\t\t\t//  ...so we set \"user\" param of \"token\" to object from \"authorize\"...\n\t\t\t//  ...and return it...\n\t\t\tuser && (token.user = user);\n\t\t\treturn Promise.resolve(token); // ...here\n\t\t},\n\t\tasync session(session, user, sessionToken) {\n\t\t\t//  \"session\" is current session object\n\t\t\t//  below we set \"user\" param of \"session\" to value received from \"jwt\" callback\n\t\t\tsession.user = user.user;\n\t\t\treturn Promise.resolve(session);\n\t\t},\n\n\t\t// async jwt(token, user) {\n\t\t// \tif (user) {\n\t\t// \t\tconsole.log(\"jwt user\", user);\n\t\t// \t\tconsole.log(\"jwt token\", token);\n\t\t// \t\ttoken.accessToken = user.data.token;\n\t\t// \t}\n\t\t// \treturn token;\n\t\t// },\n\t\t// async session(session, token) {\n\t\t// \tconsole.log(\"session\", session);\n\t\t// \tconsole.log(\"session token\", token);\n\t\t// \tsession.accessToken = token.accessToken;\n\n\t\t// \treturn session;\n\t\t// },\n\t},\n\tpages: {\n\t\tsignIn: \"/LoginRegister\",\n\t\tnewUser: \"/NewUser\",\n\t},\n\t// @ts-ignore\n\tadapter: Adapters.Prisma.Adapter({\n\t\tprisma,\n\t}),\n\n\tsecret: process.env.SECRET,\n};\n"]},"metadata":{},"sourceType":"module"}